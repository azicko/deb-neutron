From 4dde0ffdddeaddef219d0ff6d131d474ec190167 Mon Sep 17 00:00:00 2001
From: Sylvain Afchain <sylvain.afchain@enovance.com>
Date: Thu, 12 Dec 2013 23:20:17 +0100
Subject: [PATCH] Add parameter and iptables rules to protect dnsmasq ports

Add a paramater to the configuration file of the dhcp
agent. With this new param set as true, iptables rules
are inserted to limit dns requests to dnsmasq only to
the clients which are on the same subnet.

Change-Id: Iac3635326cb81d5de51b903510ff31cb6164aa86
Closes-bug: #1260731
Last-Update: 2014-06-30
---
 etc/dhcp_agent.ini                    |    5 +
 neutron/agent/linux/dhcp.py           |  159 ++++++++++++++++++++
 neutron/tests/unit/test_linux_dhcp.py |  259 ++++++++++++++++++++++++++++++++-
 3 files changed, 421 insertions(+), 2 deletions(-)

--- a/etc/dhcp_agent.ini
+++ b/etc/dhcp_agent.ini
@@ -86,3 +86,8 @@
 # Timeout for ovs-vsctl commands.
 # If the timeout expires, ovs commands will fail with ALARMCLOCK error.
 # ovs_vsctl_timeout = 10
+
+# Limits the dns requests to dnsmasq only to clients which are on its subnet.
+# Useful when a subnet is routed to another one or in the case of an
+# external network.
+# isolate_dns_requests = False
--- a/neutron/agent/linux/dhcp.py
+++ b/neutron/agent/linux/dhcp.py
@@ -26,6 +26,7 @@
 import six
 
 from neutron.agent.linux import ip_lib
+from neutron.agent.linux import iptables_manager
 from neutron.agent.linux import utils
 from neutron.common import constants
 from neutron.common import exceptions
@@ -57,6 +58,9 @@
         'dnsmasq_lease_max',
         default=(2 ** 24),
         help=_('Limit number of leases to prevent a denial-of-service.')),
+    cfg.BoolOpt('isolate_dns_requests', default=False,
+                help=_("Allow dns requests to dnsmasq only from clients "
+                       "on its subnet.")),
 ]
 
 IPV4 = 4
@@ -73,6 +77,7 @@
 METADATA_PORT = 80
 WIN2k3_STATIC_DNS = 249
 NS_PREFIX = 'qdhcp-'
+DNS_CHAIN_PREFIX = 'dns-'
 
 
 class DictModel(dict):
@@ -807,7 +812,67 @@
             sock.close()
 
 
+class NamespaceIptablesManagerCache(object):
+    def __init__(self):
+        self.iptables_managers = {}
+        self.subnets = {}
+
+    def get_or_create(self, network, root_helper):
+        ns = network.namespace
+
+        im = self.iptables_managers.get(ns)
+        if not im:
+            im = iptables_manager.IptablesManager(
+                root_helper=root_helper,
+                use_ipv6=True,
+                namespace=network.namespace)
+            self.iptables_managers[ns] = im
+
+        return im
+
+    def is_up_to_date(self, network):
+        subnets = self.subnets.get(network.id)
+        current_subnets = set([subnet.id for subnet in network.subnets])
+        return subnets == current_subnets
+
+    def get(self, network):
+        return self.iptables_managers.get(network.namespace)
+
+    def remove(self, network):
+        self.subnets.pop(network.id, None)
+        self.iptables_managers.pop(network.namespace, None)
+
+    def apply(self, network):
+        im = self.iptables_managers.get(network.namespace)
+        if not im:
+            LOG.warn(_("apply called on a non existant iptables_manager "
+                       "for network %s, get_or_create has to be called "
+                       "before"), network.id)
+            return
+
+        self.subnets[network.id] = set([subnet.id
+                                        for subnet in network.subnets])
+
+        im.apply()
+
+
+class InterfaceNameCache(object):
+    def __init__(self):
+        self.interface_names = {}
+
+    def set(self, network, interface_name):
+        self.interface_names[network.id] = interface_name
+
+    def get(self, network):
+        return self.interface_names.get(network.id)
+
+    def remove(self, network):
+        self.interface_names.pop(network.id, None)
+
+
 class DeviceManager(object):
+    iptables_manager_cache = NamespaceIptablesManagerCache()
+    interface_name_cache = InterfaceNameCache()
 
     def __init__(self, conf, root_helper, plugin):
         self.conf = conf
@@ -956,6 +1021,87 @@
 
         return dhcp_port
 
+    @staticmethod
+    def _get_isolation_rule(proto, chain, interface):
+        return ('-p %(proto)s -m %(proto)s '
+                '--dport %(port)s -i %(interface)s '
+                '-j $%(chain)s') % {'port': DNS_PORT,
+                                    'proto': proto,
+                                    'chain': chain,
+                                    'interface': interface}
+
+    def _remove_dns_isolation(self, network):
+        interface_name = DeviceManager.interface_name_cache.get(network)
+        if not interface_name:
+            LOG.warn(_("Error unable to get interface name for network: %s"),
+                     network.id)
+            return
+
+        im = DeviceManager.iptables_manager_cache.get(network)
+        if not im:
+            LOG.error(_("Error unable get the iptables manager created "
+                        "for network %s"), network.id)
+            return
+
+        rules_chain = iptables_manager.get_chain_name(DNS_CHAIN_PREFIX +
+                                                      network.id)
+
+        for tables in [im.ipv4, im.ipv6]:
+            tables['filter'].remove_chain(rules_chain)
+
+        im.apply()
+
+        DeviceManager.iptables_manager_cache.remove(network)
+
+    def _apply_dns_isolation(self, network, interface_name=None):
+        if DeviceManager.iptables_manager_cache.is_up_to_date(
+            network):
+            return
+
+        im = DeviceManager.iptables_manager_cache.get_or_create(
+            network, self.root_helper)
+        if not im:
+            LOG.error(_("Error unable to create or get an iptables manager "
+                        "for network %s"), network.id)
+            return
+
+        if not interface_name:
+            interface_name = DeviceManager.interface_name_cache.get(network)
+        if not interface_name:
+            LOG.error(_("Error unable to get interface name for network: %s"),
+                      network.id)
+            return
+
+        rules_chain = iptables_manager.get_chain_name(DNS_CHAIN_PREFIX +
+                                                      network.id)
+
+        for tables in [im.ipv4, im.ipv6]:
+            tables['filter'].add_chain(rules_chain)
+
+            # empty_chain has to be called since a previous subnet
+            # could be now removed, with an empty chain only current subnet
+            # rules will be present.
+            tables['filter'].empty_chain(rules_chain)
+            tables['filter'].add_rule(rules_chain, '-j DROP')
+
+            for proto in [UDP, TCP]:
+                rule = self._get_isolation_rule(proto, rules_chain,
+                                                interface_name)
+                tables['filter'].add_rule('INPUT', rule)
+
+        # allow traffic from subnets everything else will be denied
+        for subnet in network.subnets:
+            if not subnet.enable_dhcp:
+                continue
+
+            tables = im.ipv4 if subnet.ip_version == IPV4 else im.ipv6
+
+            rule = '-s ' + subnet.cidr + ' -j RETURN'
+            tables['filter'].add_rule(rules_chain,
+                                      rule, top=True)
+
+        DeviceManager.iptables_manager_cache.apply(network)
+
     def setup(self, network):
         """Create and initialize a device for network's DHCP on this host."""
         port = self.setup_dhcp_port(network)
@@ -994,6 +1140,9 @@
         if self.conf.use_namespaces:
             self._set_default_route(network, interface_name)
 
+        if self.conf.isolate_dns_requests:
+            self._apply_dns_isolation(network, interface_name)
+
         return interface_name
 
     def update(self, network, device_name):
@@ -1001,9 +1150,17 @@
         if self.conf.use_namespaces:
             self._set_default_route(network, device_name)
 
+        if self.conf.isolate_dns_requests:
+            self._apply_dns_isolation(network)
+
     def destroy(self, network, device_name):
         """Destroy the device used for the network's DHCP on this host."""
+        if self.conf.isolate_dns_requests:
+            self._remove_dns_isolation(network)
+
         self.driver.unplug(device_name, namespace=network.namespace)
 
         self.plugin.release_dhcp_port(network.id,
                                       self.get_device_id(network))
+
+        DeviceManager.interface_name_cache.remove(network)
